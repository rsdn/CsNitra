КОНТЕКСТ ОБСУЖДЕНИЯ:
Анализируется генерализованный PEG-парсер с особенностями:
- Генерализованный разбор: вместо "первого успешного" выбирается вариант, продвигающийся дальше
- TDOP-подход: разделение на prefix/postfix правила с приоритетами  
- Мемоизация: кэширование результатов по (позиция, правило, приоритет)
- Безлексерность: контекстные терминалы (абстрагированные за типом Terminal, разбор которых герерируется генератором кода), интегрированная обработка тривиа

ПРОБЛЕМА ВОССТАНОВЛЕНИЯ ПОСЛЕ ОШИБОК:
Текущее состояние: реализовано базовое восстановление через OftenMissed и recovery-правила
Не решена: автоматическое паник-восстановление с гарантированным разбором до конца

КЛЮЧЕВЫЕ ПРОБЛЕМЫ ДЛЯ РЕШЕНИЯ:
1. Частичные разборы: как идентифицировать и сохранять частично разобранные правила при падении
2. Динамический FOLLOW: вычисление точек продолжения с учетом стека вызовов, а не только статической грамматики  
3. Мемоизация при восстановлении: как переиспользовать/инвалидировать мемо-записи при повторном разборе с восстановлением
4. Универсальные стратегии: алгоритмы восстановления, работающие для любой грамматики без хардкода языковых конструкций

РЕШЕНИЕ ПО ИЕРАРХИИ RESULT:
Ввести полиморфную иерархию Result вместо struct:
- SuccessResult: успешный разбор (ISyntaxNode + NewPos)
- FailureResult: полный провал (FailPos)
- PartialResult: частичный разбор (PartialNode + ParsedPos + ErrorInfo + CallStack)

PartialResult создается когда:
- В Seq разобрано несколько элементов но не все
- В TDOP префикс разобран но постфикс упал
- В списках разобраны некоторые элементы

МЕХАНИЗМ ДОРАЗБОРА:
При получении PartialResult парсер переходит в режим RecoveryContext:
1. Сохраняется состояние стека и частичные разборы
2. Анализируются возможные точки продолжения через динамический FOLLOW
3. Выбирается оптимальная стратегия восстановления
4. Запускается повторный разбор с модифицированной мемоизацией

МОДИФИКАЦИЯ МЕМОИЗАЦИИ:
Вместо второго словаря использовать переупаковку мемо-записей:
- При RecoveryContext.IsActive мемо-записи "переупаковываются" через WithRecoveryContext()
- SuccessResult и FailureResult возвращаются как есть
- PartialResult дополняется контекстом восстановления
- Инвалидация только для записей зависящих от измененного участка

ПРЕДЛОЖЕННАЯ АРХИТЕКТУРА:
UniversalRecoveryEngine с иерархией стратегий:
- RepetitionContinuationStrategy: продолжение циклов (ZeroOrMany/OneOrMany)
- StructuralPatternStrategy: блоки, списки, выражения (выявляется автоматически из грамматики)
- FollowSetStrategy: динамические FOLLOW-терминалы с учетом стека вызовов
- TriviaBasedSkipStrategy: пропуск через тривиа
- SingleTokenSkipStrategy: гарантированный пропуск по одному токену

АЛГОРИТМ ВОССТАНОВЛЕНИЯ:
1. При PartialResult анализируется стек вызовов и грамматика
2. Вычисляются точки продолжения через динамический FOLLOW
3. Ранжируются кандидаты по Confidence (High/Medium/Low)
4. Выбирается оптимальная стратегия
5. Запускается доразбор с прикреплением пропущенного текста к последнему успешному терминалу

КОНКРЕТНЫЕ ВОПРОСЫ ДЛЯ ПРОДОЛЖЕНИЯ:
1. Как эффективно вычислять динамические FOLLOW-множества с учетом стека вызовов
2. Как детектировать структурные паттерны (блоки, списки, выражения) автоматически из грамматики
3. Механизм "переупаковки" мемо-записей для восстановления без потери производительности
4. Алгоритм выбора оптимальной точки восстановления при множественных кандидатах
5. Интеграция частичных разборов в существующую TDOP-архитектуру
6. Обработка предикатов (And/Not) при частичном разборе
7. Гарантия завершения при каскадных ошибках

Проблема поиска самого глубокого падения
1. Падение может быть в прдикате, что создает ложное изменение точки самого глубокого облома (ErrorPos) для каждого шага продолжения паринга.
2. Разбор при восстановлении может принять похожие по префику конструкции за часть следующего правила. Например, "void Foo() { X  int Bar() { return 42; }"
   может принять "int Bar" за начало стейтмента, хотя человек пропустил "}" и подразумевал под Bar не переменную, а декларацию функции.
   Такие моменты надо как-то тоже обрабатывать. В данном случае видится, что "int Bar() { return" это однозначный префикс декларации функции
   и он динее незавершенного объявления локальной переменной "int Bar", так что по идее должен быть предпочтён более длинный предикат. Надо продумать.
   Режим паники не подразумевает вставки токенов. Но мы должны поддерживать эту фичу хотя бы на уровне задаваемой пользовтелем.
   Некоторые люди часто забывают поставить "}" в конце блока.
   В общем, нужно продумать совмещение с другими стратегиями восстановления.
   
Все предложения по модификации кода парсера должны быть абстрактны
1. Единственное, что парсер знает о разбираемом языке - это его граматика. Нельзя предлагать решения основанные на знании о конкретном языке в коде парсера.
2. Парсер так же не дожен знать ничего о кокнетрых токенах. Они так же заданы грамматикой.
3. Можно предлагать расширения описания граматики, если они позволят пользовтелю аннотировать грамматику так, чтобы увеличивать качесво разбора.
